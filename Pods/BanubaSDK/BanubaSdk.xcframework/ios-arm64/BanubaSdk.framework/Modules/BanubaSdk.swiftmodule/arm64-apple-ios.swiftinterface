// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.1 (swiftlang-1200.0.41 clang-1200.0.32.8)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name BanubaSdk
import Accelerate
import BanubaEffectPlayer
@_exported import BanubaSdk
import CoreMotion
import Foundation
import MediaPlayer
import Swift
import UIKit
public protocol RenderEffect : AnyObject {
  var name: Swift.String { get }
  var isLoaded: Swift.Bool { get }
  var isActive: Swift.Bool { get set }
  func load(size: CoreGraphics.CGSize)
  func unload()
  func apply(params: Swift.Dictionary<Swift.String, Swift.String>)
}
public class ColorEffect : BanubaSdk.RenderEffect {
  public var name: Swift.String
  public var isLoaded: Swift.Bool {
    get
  }
  public var isActive: Swift.Bool
  public init(file url: Foundation.URL)
  public func load(size: CoreGraphics.CGSize)
  public func unload()
  public func apply(params: Swift.Dictionary<Swift.String, Swift.String>)
  @objc deinit
}
public class ShaderEffect : BanubaSdk.RenderEffect {
  public var name: Swift.String
  public var isLoaded: Swift.Bool {
    get
  }
  public var isActive: Swift.Bool
  public init(name: Swift.String)
  public func load(size: CoreGraphics.CGSize)
  public func unload()
  public func apply(params: Swift.Dictionary<Swift.String, Swift.String>)
  @objc deinit
}
public enum EffectPlayerRenderMode {
  case photo
  case video
  public static func == (a: BanubaSdk.EffectPlayerRenderMode, b: BanubaSdk.EffectPlayerRenderMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct EffectPlayerVideoSize {
  public static let hd720x1280: CoreGraphics.CGSize
  public static let hd960x1280: CoreGraphics.CGSize
}
public struct EffectPlayerConfiguration {
  public let cameraMode: BanubaSdk.CameraSessionType
  public let paths: [Swift.String]
  public var renderSize: CoreGraphics.CGSize
  public let videoSize: CoreGraphics.CGSize
  public var shouldAutoStartOnEnterForeground: Swift.Bool
  public var fov: Swift.UInt
  public var isMirrored: Swift.Bool
  public var flipVertically: Swift.Bool
  public var orientation: BanubaEffectPlayer.BNBCameraOrientation
  public var notificationCenter: Foundation.NotificationCenter
  public var logLevel: BanubaEffectPlayer.BNBSeverityLevel
  public var allPaths: [Swift.String] {
    get
  }
  public init(paths: [Swift.String], renderMode: BanubaSdk.EffectPlayerRenderMode, videoSize: CoreGraphics.CGSize, orientation: BanubaEffectPlayer.BNBCameraOrientation = .deg0, shouldAutoStartOnEnterForeground: Swift.Bool = true, isMirrored: Swift.Bool = false, fov: Swift.UInt = 0, notificationCenter: Foundation.NotificationCenter = NotificationCenter.default)
  public init(paths: [Swift.String], cameraMode: BanubaSdk.CameraSessionType, renderSize: CoreGraphics.CGSize, videoSize: CoreGraphics.CGSize, orientation: BanubaEffectPlayer.BNBCameraOrientation = .deg0, shouldAutoStartOnEnterForeground: Swift.Bool = true, isMirrored: Swift.Bool = false, flipVertically: Swift.Bool = true, fov: Swift.UInt = 0, notificationCenter: Foundation.NotificationCenter = NotificationCenter.default, logLevel: BanubaEffectPlayer.BNBSeverityLevel = .info)
}
@objc @_hasMissingDesignatedInitializers public class EffectTextArea : ObjectiveC.NSObject {
  final public let name: Swift.String
  @objc deinit
  @objc override dynamic public init()
}
public struct WatermarkInfo {
  public init(image: UIKit.UIImage, normalizedPosition: CoreGraphics.CGPoint, normalizedWidth: CoreGraphics.CGFloat?, normalizedHeight: CoreGraphics.CGFloat?)
}
extension BNBTouch {
  convenience public init(_ touch: UIKit.UITouch)
}
public protocol BanubaSdkEffectEventListener : AnyObject {
  func didTouch(eventName: Swift.String, parameters: [Swift.String : Swift.String])
}
public protocol BanubaSdkDelegate : AnyObject {
  func willOutput(pixelBuffer: CoreVideo.CVPixelBuffer)
}
@_hasMissingDesignatedInitializers public class BanubaSdkManager {
  weak public var delegate: BanubaSdk.BanubaSdkDelegate?
  public var isStarted: Swift.Bool {
    get
  }
  public var effectPlayer: BanubaEffectPlayer.BNBEffectPlayer?
  weak public var effectEventListener: BanubaSdk.BanubaSdkEffectEventListener?
  public var faceOrientation: Swift.Int?
  public static let instance: BanubaSdk.BanubaSdkManager
  public static var clientToken: Swift.String?
  public var voiceChanger: BanubaSdk.VoiceChangeable {
    get
    set
  }
  public var input: BanubaSdk.InputServicing {
    get
    set
  }
  public var output: BanubaSdk.OutputServicing {
    get
  }
  public var effects: BanubaSdk.EffectsServicing {
    get
  }
  public var playerConfiguration: BanubaSdk.EffectPlayerConfiguration? {
    get
  }
  public func setupMaskPostproccessService(context: OpenGLES.EAGLContext)
  public func setRenderTarget(layer: QuartzCore.CAEAGLLayer, renderMode: BanubaSdk.EffectPlayerRenderMode)
  public func setRenderTarget(layer: QuartzCore.CAEAGLLayer, playerConfiguration: BanubaSdk.EffectPlayerConfiguration?)
  public func removeRenderTarget()
  public func loadMask(name: Swift.String) -> BanubaSdk.EffectSettingsProtocol?
  public func setText(_ text: Swift.String, color: UIKit.UIColor, area: BanubaSdk.EffectTextArea)
  public var renderQueue: Dispatch.DispatchQueue {
    get
  }
  public var shouldAutoStartOnEnterForeground: Swift.Bool
  public var isLoaded: Swift.Bool {
    get
  }
  @objc deinit
  public func deinitialize()
  public func setup(configuration: BanubaSdk.EffectPlayerConfiguration)
}
extension BanubaSdkManager : BanubaSdk.InputServiceDelegate {
  public func push(buffer: CoreMedia.CMSampleBuffer)
  public func push(buffer: CoreVideo.CVPixelBuffer)
}
extension BanubaSdkManager {
  public func setFrameDataRecord(_ isRecord: Swift.Bool)
}
extension BanubaSdkManager {
  public func setEffectVolume(_ volume: Swift.Float)
  public func startEffectPlayer()
  public func stopEffectPlayer()
  public func destroyEffectPlayer()
  public func makeCameraPhoto(cameraSettings: BanubaSdk.CameraPhotoSettings, completion: @escaping (CoreVideo.CVImageBuffer?) -> Swift.Void)
  public func processImageData(imageBuffer: CoreVideo.CVImageBuffer, isMirrored: Swift.Bool, orientation: BanubaEffectPlayer.BNBCameraOrientation = .deg90, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
  public func processImageData(_ inputData: CoreVideo.CVImageBuffer, width: Swift.UInt, height: Swift.UInt, orientation: BanubaEffectPlayer.BNBCameraOrientation = .deg0, isMirrored: Swift.Bool = false, inputFormat: BanubaEffectPlayer.BNBPixelFormat = .rgba, outputFormat: BanubaEffectPlayer.BNBPixelFormat = .rgba, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
  public func configureWatermark(_ watermarkInfo: BanubaSdk.WatermarkInfo)
  public func removeWatermark()
  public func startVideoProcessing(width: Swift.UInt, height: Swift.UInt, orientation: BanubaEffectPlayer.BNBCameraOrientation = .deg0, resetEffect: Swift.Bool = false)
  public func stopVideoProcessing(resetEffect: Swift.Bool = false)
  public func processVideoFrame(from: CoreVideo.CVPixelBuffer, to: CoreVideo.CVPixelBuffer, timeNs: Swift.Int64, iterations: Swift.Int? = nil, cameraOrientation: BanubaEffectPlayer.BNBCameraOrientation = .deg0, requireMirroring: Swift.Bool = false, faceOrientation: Swift.Int = 0, processImageParams: BanubaEffectPlayer.BNBProcessImageParams = BNBProcessImageParams(acneProcessing: false, acneUserAreas: nil, faceDataJsonPath: nil))
}
extension BanubaSdkManager : BanubaEffectPlayer.BNBEffectEventListener {
  @objc dynamic public func onEffectEvent(_ name: Swift.String, params: [Swift.String : Swift.String])
}
extension BanubaSdkManager : BanubaSdk.MaskPostprocessServicing {
  public func postprocessProcessVideoFrame(_ from: CoreVideo.CVPixelBuffer, to: CoreVideo.CVPixelBuffer, time: CoreMedia.CMTime)
  public func postprocessStopVideoProcessing()
  public func postprocessPlaybackStop()
  public func postprocessSurfaceDestroyed()
  public func postprocessSurfaceCreated(with size: CoreGraphics.CGSize)
  public func postprocessSetEffectSize(_ size: CoreGraphics.CGSize)
  public func postprocessLoadEffect(path: Swift.String)
  public func postprocessStartVideoProcessing(with size: CoreGraphics.CGSize)
  public func postprocessDraw()
}
extension UITouch {
  public var id: Swift.Int64 {
    get
  }
}
public protocol EffectSettingsProtocol : AnyObject {
  var textAreas: [BanubaSdk.EffectTextArea]? { get }
}
public protocol VoiceChangeable {
  var queue: Dispatch.DispatchQueue { get set }
  var volume: Swift.Float { get set }
  var isConfigured: Swift.Bool { get }
  func process(file url: Foundation.URL, completion: ((Swift.Bool, Swift.Error?) -> Swift.Void)?)
  func process(file url: Foundation.URL) throws
}
public enum VoiceChangerError : Swift.Error {
  case cantCreateAssetExportSession
  case exportSessionCantExportAudio
  public static func == (a: BanubaSdk.VoiceChangerError, b: BanubaSdk.VoiceChangerError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc @_inheritsConvenienceInitializers public class EffectPlayerView : BanubaSdk.EffectPlayerTouchView {
  @objc override dynamic public class var layerClass: Swift.AnyClass {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_inheritsConvenienceInitializers public class EffectPlayerTouchView : UIKit.UIView {
  @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc override dynamic public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc override dynamic public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol OutputServicing : AnyObject {
  func takeSnapshot(handler: @escaping (UIKit.UIImage) -> Swift.Void)
  func configureWatermark(_ watermarkInfo: BanubaSdk.WatermarkInfo)
  func removeWatermark()
  func startVideoCapturing(fileURL: Foundation.URL?, progress: @escaping (CoreMedia.CMTime) -> Swift.Void, periodicProgressTimeInterval: Foundation.TimeInterval, boundaryTimes: [Foundation.NSValue], boundaryHandler: @escaping (CoreMedia.CMTime) -> Swift.Void, totalDuration: Foundation.TimeInterval, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  func stopVideoCapturing(cancel: Swift.Bool)
  func startForwardingFrames(handler: @escaping (CoreVideo.CVPixelBuffer) -> Swift.Void)
  func stopForwardingFrames()
  func reset()
  func hasDiskCapacityForRecording() -> Swift.Bool
  func videoStarted()
  func videoStopped()
  var isRecording: Swift.Bool { get }
}
@_hasMissingDesignatedInitializers public class OutputService {
  final public let renderSize: CoreGraphics.CGSize
  public var synchronousVideoCapturing: Swift.Bool
  public var isRecording: Swift.Bool {
    get
  }
  @objc deinit
}
extension OutputService : BanubaSdk.OutputServicing {
  public func startForwardingFrames(handler: @escaping (CoreVideo.CVPixelBuffer) -> Swift.Void)
  public func stopForwardingFrames()
  public func reset()
  public func configureWatermark(_ watermarkInfo: BanubaSdk.WatermarkInfo)
  public func removeWatermark()
  public func takeSnapshot(handler: @escaping (UIKit.UIImage) -> Swift.Void)
  public func startVideoCapturing(fileURL: Foundation.URL?, progress: @escaping (CoreMedia.CMTime) -> Swift.Void, periodicProgressTimeInterval: Foundation.TimeInterval, boundaryTimes: [Foundation.NSValue], boundaryHandler: @escaping (CoreMedia.CMTime) -> Swift.Void, totalDuration: Foundation.TimeInterval, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  public func stopVideoCapturing(cancel: Swift.Bool)
  public func videoStarted()
  public func videoStopped()
  public func hasDiskCapacityForRecording() -> Swift.Bool
}
public protocol EffectsServicing {
  var availableShaderEffects: [Swift.String] { get }
  func apply(effect: BanubaSdk.RenderEffect)
  func remove(effect: BanubaSdk.RenderEffect)
  func removeAll()
}
@_hasMissingDesignatedInitializers public class EffectsService : BanubaSdk.EffectsServicing {
  final public let availableShaderEffects: [Swift.String]
  public func apply(effect: BanubaSdk.RenderEffect)
  public func remove(effect: BanubaSdk.RenderEffect)
  public func removeAll()
  @objc deinit
}
public typealias InputServicing = BanubaSdk.AudioCapturing & BanubaSdk.CameraServicing & BanubaSdk.CameraZoomable
public typealias AVCaptureDataDelegate = AVFoundation.AVCaptureAudioDataOutputSampleBufferDelegate & AVFoundation.AVCapturePhotoCaptureDelegate & AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate
public protocol CameraServicing : AnyObject {
  var delegate: BanubaSdk.InputServiceDelegate? { get set }
  var isFrontCamera: Swift.Bool { get }
  var isPhotoCameraSession: Swift.Bool { get }
  var isCameraCapturing: Swift.Bool { get }
  var currentCameraSessionType: BanubaSdk.CameraSessionType { get }
  var exposurePointOfInterest: CoreGraphics.CGPoint { get }
  func startCamera()
  func stopCamera(completion: (() -> Swift.Void)?)
  func toggleTorch() -> AVFoundation.AVCaptureDevice.TorchMode
  func setTorch(mode: AVFoundation.AVCaptureDevice.TorchMode) -> AVFoundation.AVCaptureDevice.TorchMode
  func setCameraSessionType(_ type: BanubaSdk.CameraSessionType)
  func configureExposureSettings(_ point: CoreGraphics.CGPoint?, useContinuousDetection: Swift.Bool)
  func configureFocusSettings(_ point: CoreGraphics.CGPoint?, useContinuousDetection: Swift.Bool)
  func initiatePhotoCapture(cameraSettings: BanubaSdk.CameraPhotoSettings, completion: @escaping (CoreVideo.CVImageBuffer?) -> Swift.Void)
}
public protocol AudioCapturing : AnyObject {
  func startAudioCapturing()
  func stopAudioCapturing()
}
public protocol CameraZoomable : AnyObject {
  var isZoomFactorAdjustable: Swift.Bool { get }
  var minZoomFactor: Swift.Float { get }
  var maxZoomFactor: Swift.Float { get }
  var zoomFactor: Swift.Float { get }
  func setZoomFactor(_ zoomFactor: Swift.Float) -> Swift.Float
}
public protocol InputServiceDelegate : AnyObject {
  func push(buffer: CoreVideo.CVPixelBuffer)
  func push(buffer: CoreMedia.CMSampleBuffer)
}
@frozen public enum CameraSessionType {
  case FrontCameraVideoSession
  case BackCameraVideoSession
  case FrontCameraPhotoSession
  case BackCameraPhotoSession
  public static func == (a: BanubaSdk.CameraSessionType, b: BanubaSdk.CameraSessionType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct CameraPhotoSettings {
  public let useStabilization: Swift.Bool
  public let flashMode: AVFoundation.AVCaptureDevice.FlashMode
  public init(useStabilization: Swift.Bool, flashMode: AVFoundation.AVCaptureDevice.FlashMode)
}
@objc public class InputService : ObjectiveC.NSObject {
  public enum InputServiceError : Swift.Error {
    case CameraDeviceInitializationFailed
    case CameraInputInitializationFailed
    case AudioDeviceInitializationFailed
    case AudioInputInitializationFailed
    public static func == (a: BanubaSdk.InputService.InputServiceError, b: BanubaSdk.InputService.InputServiceError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var cameraDevice: AVFoundation.AVCaptureDevice?
  public var cameraSessionQueue: Dispatch.DispatchQueue {
    get
    set
  }
  weak public var delegate: BanubaSdk.InputServiceDelegate?
  public init(cameraMode: BanubaSdk.CameraSessionType)
  @objc deinit
  public func setupCameraSession(withType type: BanubaSdk.CameraSessionType)
  @objc override dynamic public init()
}
extension InputService : BanubaSdk.AVCaptureDataDelegate {
  @objc dynamic public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didOutput sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
  @objc dynamic public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didDrop sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
  @objc dynamic public func photoOutput(_ output: AVFoundation.AVCapturePhotoOutput, didFinishProcessingRawPhoto rawSampleBuffer: CoreMedia.CMSampleBuffer?, previewPhoto previewPhotoSampleBuffer: CoreMedia.CMSampleBuffer?, resolvedSettings: AVFoundation.AVCaptureResolvedPhotoSettings, bracketSettings: AVFoundation.AVCaptureBracketedStillImageSettings?, error: Swift.Error?)
  @objc dynamic public func photoOutput(_ output: AVFoundation.AVCapturePhotoOutput, didFinishProcessingPhoto photoSampleBuffer: CoreMedia.CMSampleBuffer?, previewPhoto previewPhotoSampleBuffer: CoreMedia.CMSampleBuffer?, resolvedSettings: AVFoundation.AVCaptureResolvedPhotoSettings, bracketSettings: AVFoundation.AVCaptureBracketedStillImageSettings?, error: Swift.Error?)
}
extension InputService : BanubaSdk.InputServicing {
  public func configureFocusSettings(_ point: CoreGraphics.CGPoint?, useContinuousDetection: Swift.Bool)
  public func configureExposureSettings(_ point: CoreGraphics.CGPoint?, useContinuousDetection: Swift.Bool)
  public var exposurePointOfInterest: CoreGraphics.CGPoint {
    get
  }
  public var isZoomFactorAdjustable: Swift.Bool {
    get
  }
  public var minZoomFactor: Swift.Float {
    get
  }
  public var maxZoomFactor: Swift.Float {
    get
  }
  public var zoomFactor: Swift.Float {
    get
  }
  public func setZoomFactor(_ zoomFactor: Swift.Float) -> Swift.Float
  public func setTorch(mode: AVFoundation.AVCaptureDevice.TorchMode) -> AVFoundation.AVCaptureDevice.TorchMode
  public func toggleTorch() -> AVFoundation.AVCaptureDevice.TorchMode
  public func startCamera()
  public func stopCamera(completion: (() -> Swift.Void)?)
  public func initiatePhotoCapture(cameraSettings: BanubaSdk.CameraPhotoSettings, completion: @escaping (CoreVideo.CVImageBuffer?) -> Swift.Void)
  public var isPhotoCameraSession: Swift.Bool {
    get
  }
  public var isFrontCamera: Swift.Bool {
    get
  }
  public var isCameraCapturing: Swift.Bool {
    get
  }
  public var currentCameraSessionType: BanubaSdk.CameraSessionType {
    get
  }
  public func setCameraSessionType(_ type: BanubaSdk.CameraSessionType)
  public func startAudioCapturing()
  public func stopAudioCapturing()
}
extension InputService {
  @objc override dynamic public func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
}
extension CameraSessionType {
  public var isFrontCamera: Swift.Bool {
    get
  }
  public var isPhotoMode: Swift.Bool {
    get
  }
}
public protocol SnapshotProvider {
  func makeSnapshot() -> UIKit.UIImage
  func makeSnapshotWithWatermark(_ watermarkPixelBuffer: CoreVideo.CVPixelBuffer) -> UIKit.UIImage
}
public protocol PixelBufferProvider {
  func makeVideoPixelBuffer() -> CoreVideo.CVPixelBuffer
}
extension BanubaRenderTarget : BanubaSdk.SnapshotProvider {
  public func makeSnapshotWithWatermark(_ watermarkPixelBuffer: CoreVideo.CVPixelBuffer) -> UIKit.UIImage
  public func makeSnapshot() -> UIKit.UIImage
}
extension BanubaRenderTarget : BanubaSdk.PixelBufferProvider {
  public func makeVideoPixelBuffer() -> CoreVideo.CVPixelBuffer
}
public protocol MaskPostprocessServicing : AnyObject {
  func postprocessProcessVideoFrame(_ from: CoreVideo.CVPixelBuffer, to: CoreVideo.CVPixelBuffer, time: CoreMedia.CMTime)
  func postprocessStopVideoProcessing()
  func postprocessPlaybackStop()
  func postprocessSurfaceDestroyed()
  func postprocessSurfaceCreated(with size: CoreGraphics.CGSize)
  func postprocessSetEffectSize(_ size: CoreGraphics.CGSize)
  func postprocessLoadEffect(path: Swift.String)
  func postprocessStartVideoProcessing(with size: CoreGraphics.CGSize)
  func postprocessDraw()
}
extension BanubaSdk.EffectPlayerRenderMode : Swift.Equatable {}
extension BanubaSdk.EffectPlayerRenderMode : Swift.Hashable {}
extension BanubaSdk.VoiceChangerError : Swift.Equatable {}
extension BanubaSdk.VoiceChangerError : Swift.Hashable {}
extension BanubaSdk.CameraSessionType : Swift.Equatable {}
extension BanubaSdk.CameraSessionType : Swift.Hashable {}
extension BanubaSdk.InputService.InputServiceError : Swift.Equatable {}
extension BanubaSdk.InputService.InputServiceError : Swift.Hashable {}
